<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手写 bind</title>
      <link href="/blog//2021/04/handwritten-bind.html"/>
      <url>/blog//2021/04/handwritten-bind.html</url>
      
        <content type="html"><![CDATA[<p>常见的调用方式如下</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">func</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>bind</code>是绑定函数执行上下文中的<code>this</code>属性，<code>bind</code>和<code>call</code>，<code>apply</code>其他两个函数不一样，它不只是一次函数调用，它还返回了一个新的函数，所以<code>bind</code>的基本结构如下</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">thisArg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于是在<code>func</code>函数上调用的<code>bind</code>，因此<code>bind</code>是绑定到<code>Function.prototype</code>上的，于是</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">thisArg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本格式确定了，关键是怎么把<code>thisArg</code>设置为新函数的<code>this</code>呢？假如可以使用<code>apply</code>的话，只要获取到之前的函数，然后调用<code>apply</code>绑定新的<code>this</code>即可。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">thisArg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span>    <span class="token comment">// ...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进一步，我们需要考虑<code>bind</code>是可以预置参数的，而之后新函数调用也是可以传递参数的，对参数进行一个合并</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">thisArg<span class="token punctuation">,</span> <span class="token operator">...</span>bindArgs</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> newArgs <span class="token operator">=</span> bindArgs<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> newArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是构造函数使用上面定义的bind，自然是不行的，因为很明显 bind 之后返回了新的函数，而非原来的构造函数。如下所示</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">mybind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">thisArg<span class="token punctuation">,</span> <span class="token operator">...</span>bindArgs</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> newArgs <span class="token operator">=</span> bindArgs<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> newArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Point</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 使用 mybind</span><span class="token keyword">let</span> YAxisPoint <span class="token operator">=</span> Point<span class="token punctuation">.</span><span class="token function">mybind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">YAxisPoint</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [object Object]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token comment">// 使用原生bind</span><span class="token keyword">let</span> YAxisPoint2 <span class="token operator">=</span> <span class="token function">Point</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">YAxisPoint2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0,5</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于<code>YAxisPoint</code>来说，它是在<code>mybind</code>里面返回的那个函数，并不是<code>Point</code>或者<code>Point</code>的子类，因而<code>p1.toString</code>的结果并非预期的是<code>0,5</code>。</p><p>如果要与原生的<code>bind</code>一样，支持对新的函数使用<code>new</code>进行实例化，那么其实就是要实现一个”经典继承“，或者说”盗用构造函数“，因此对于<code>mybind</code>函数而言，就是要同时支持直接调用或实现经典继承，关键一步的伪代码如下</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>isCallByNew <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> thisArg<span class="token punctuation">,</span> newArgs<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其实就是<code>this</code>绑定目标对象的区别。当然，以上是不够的，还需要继承原构造函数的<code>prototype</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">mybind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">thisArg<span class="token punctuation">,</span> <span class="token operator">...</span>bindArgs</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> newArgs <span class="token operator">=</span> bindArgs<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">func</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> thisArg<span class="token punctuation">,</span> newArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    func<span class="token punctuation">.</span>prototype <span class="token operator">=</span> self<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> func<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里设置了新的构造函数<code>func</code>和原构造函数的<code>prototype</code>指向同一个。</p><p>最终的代码如下</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">mybind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">thisArg<span class="token punctuation">,</span> <span class="token operator">...</span>bindArgs</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> newArgs <span class="token operator">=</span> bindArgs<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">func</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> thisArg<span class="token punctuation">,</span> newArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    func<span class="token punctuation">.</span>prototype <span class="token operator">=</span> self<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> func<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Point</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 使用 mybind</span><span class="token keyword">let</span> YAxisPoint <span class="token operator">=</span> Point<span class="token punctuation">.</span><span class="token function">mybind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">YAxisPoint</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0,5</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有的实现会考虑新老语法的兼容，我觉得大可不必，写 bind 的目的并不在此。</p><p>有的实现考虑使用原型链来生成新的<code>prototype</code>，我觉得也大可不必，要实现的是 bind，并不是要学习所谓的组合继承。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行上下文</title>
      <link href="/blog//2021/04/execution-context.html"/>
      <url>/blog//2021/04/execution-context.html</url>
      
        <content type="html"><![CDATA[<p>执行上下文(Execution Contexts，简称EC)是程序执行时的运行环境，说明执行到当前的这个位置的时候，周围是个啥情况，有些啥东西。</p><p>根据 <a href="https://262.ecma-international.org/5.1/#sec-10.3">ECMA规范中的定义</a>，上下文由以下三个部分组成</p><img src="/blog/2021/04/execution-context/ctx.jpg" class="" title="Execution Contexts"><p>不管是 VariableEnvironment 还是 LexicalEnvironment，他们后面都可以跟上一个 Object，即把他们当做一个对象去看待。执行上下文的理解相当不容易，下面分节尝试进行说明当下的理解。</p><h2 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h2><p>VariableEnvironment 称为变量环境，简称  VE ，其 Purpose 描述如下</p><blockquote><p> Identifies the Lexical Environment whose environment record holds bindings created by VariableStatements and FunctionDeclarations within this execution context.</p></blockquote><p>请注意这里的 VariableStatements 和 FunctionDeclarations，对于这个描述，我理解为 VE 是特殊的 LE，它只包含 函数 和 var 声明，不包含通过 let, const 声明的内容。</p><p>首先我们来看一个例子，使用 var, let, const 声明了一些变量</p><img src="/blog/2021/04/execution-context/ve-0.jpg" class="" title="Variable Environment example"><p>在右侧的<code>Scope</code>中，<code>Local</code>对应当前上下文，现在还看不出有什么特别的内容。</p><p>接下来将一部分声明挪到一个<code>&#123;&#125;</code>块里面，如下</p><img src="/blog/2021/04/execution-context/ve-1.jpg" class="" title="Variable Environment example"><p>右侧显示多了一个<code>Block</code>，特别注意的是在<code>&#123;&#125;</code>块中通过<code>var</code>声明的变量 d，被提升到了 <code>Local</code> 里面。也就是说，通过 var 声明的变量，会被提升到 Local，而通过 let 和 const 声明的，将会被放到其词法作用域中。</p><p>既然 <strong>通过 let 和 const 声明的标识符，将会被放到其词法作用域中</strong>，而 foo 函数自身也构成了一个词法作用域，对于 a 和 b，我们是不是也可以拆分成两个部分呢？如下</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Block<span class="token operator">:</span> <span class="token punctuation">&#123;</span>  c<span class="token operator">:</span>  f<span class="token operator">:</span><span class="token punctuation">&#125;</span><span class="token comment">// 设想有这个 Block 的存在</span>Block0<span class="token operator">:</span> <span class="token punctuation">&#123;</span>  b<span class="token operator">:</span><span class="token punctuation">&#125;</span>VarAndFunc<span class="token operator">:</span> <span class="token punctuation">&#123;</span>  a<span class="token operator">:</span>  d<span class="token operator">:</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，就相当于把上下文中声明的所有标识符，拆分成了 <code>Block0</code> 和 <code>VarAndFunc</code>两个部分，这个<code>VarAndFunc</code>部分就是 VE。总之，可以理解为上下文中所有 函数声明 和 var声明 的标识符，保存在一个叫做 VE 的对象上。</p><h2 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h2><p>LexicalEnvironment 称为词法环境，简称 (LE)，其 Purpose 描述如下</p><blockquote><p>Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.</p></blockquote><p>根据描述，LE 是用来解析 EC 下代码的标识符引用的，这个描述，和 “Lexical Environment” 字面意义差别很大，由此带来了很多理解上的困难。</p><p><strong>Lexical Environment</strong>，当我从字面上去理解的时候，理解为 <strong>词法作用域下声明的所有标识符的引用对象</strong>。</p><p>为了便于理解，对于词法作用域，暂时不去从动/静态的角度去理解，在此处理解为 —— 任意一个形成一个作用域的局部块，都可以称为一个词法作用域。根据这个理解，词法作用域，我们也可称为局部作用域，那么函数作用域，块级作用域，都是一个词法作用域，即</p><ul><li><code>&#123;&#125;</code>局部作用域，应该对应一个 LE</li><li>函数局部作用域，应该对应一个 LE</li></ul><p>也就是说对于标识符的引用，应该是下面这个样子</p><img src="/blog/2021/04/execution-context/ctx-11.jpg" class="" title="Execution Contexts"><p>整个执行上下文中，有一个LE，<code>&#123;&#125;</code>局部作用域中，又形成一个子的 LE。如果按照这个理解，就没有什么 VE 的事情了，这一切，因为变量提升的存在，变得复杂了。</p><p>在<code>&#123;&#125;</code>对应的<code>Block</code>里面，由于变量提升，这个<code>Block</code>只包含<code>let</code>和<code>const</code>声明的标识符，LE 定义所要求的“所有”就不成立了，所以对于 LE，应该重新对定义做一下修正：</p><p><strong>词法环境包含局部作用域下 let 和 const 声明的标识符的引用</strong></p><p>也就是说，局部作用域中声明的标识符，分成了两个部分</p><ul><li>LE：保存 let 和 const 声明的标识符；</li><li>VE：保存 var 和 函数声明对应的标识符；</li></ul><p>需要注意的是</p><ul><li>VE 是“上下文级别”的，不是任何局部作用域都有的，非函数的<code>&#123;&#125;</code>执行不会创建新的上下文，内部也就没有 VE，在整个上下文中只有一个 VE；</li></ul><p>根据上面这个拆分，最终对标识符的引用对象是下面这个样子</p><img src="/blog/2021/04/execution-context/ctx-2.jpg" class="" title="Execution Contexts"><p>整体上仍旧使用了原来的“变量对象”来描述对所有标识符的引用，而内部却拆分成了 变量环境对象 和 词法环境对象 两个部分。</p><h2 id="标识符查找"><a href="#标识符查找" class="headerlink" title="标识符查找"></a>标识符查找</h2><p>在引入了块级作用域之后，在函数执行上下文中，有一个词法环境栈，栈底是函数的一个特殊的词法环境对象，当执行到某个块级词法作用域的时候，将块级作用域的词法环境对象推入到栈中。对变量进行查的时候，就从栈顶向下查找，最后再查找 变量环境对象。对于下面这个例子</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>      <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>      <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> e <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>标识符 a 的查找过程如下</p><img src="/blog/2021/04/execution-context/ctx-3.jpg" class="" title="Execution Contexts"><h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>《JavaScript高级教程》里面对“变量对象”(Variable Object，简称VO)是这样描述的：</p><blockquote><p>每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上</p></blockquote><p>在没有<code>let</code>和<code>const</code>的年代，上面的描述可以等价于</p><blockquote><p>每个上下文都有一个关联的变量对象（variable object），而这个上下文中 var 定义的所有变量，函数声明都存在于这个对象上</p></blockquote><p>当加入了 let 和 const，加入了块级作用域之后，这两个描述不等价了。第二个描述所对应的一个对象，现在叫做“变量环境”。</p><p><txt orange bold>现在这种局面，对于理解上造成了障碍：按照第二个描述，原来的 变量对象 变成了现在的 变量环境，而按照第一个描述，现在的 变量环境 却不是原来的 变量对象。</txt></p><p>我选择了仍旧使用 <strong>变量对象</strong> 这个名称来称呼 “保存上下文中定义的所有变量和函数的对象”。</p><p><txt orange>需要注意的是，变量对象是相对于上下文而言的，但并非所有的局部作用域在执行时都会创建新的上下文</txt></p><p>于是我们仍旧需要一个新的名词，用以统一称呼 “<strong>作用域</strong>定义中的变量和函数”，我称之为 作用域环境 (Scope Environment, 简称 SE)。从作用域的角度，这样一个变量：</p><ul><li>对于函数作用域，SE == VO</li><li>对于块作用域，SE == LE</li></ul><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>调用栈就是执行上下文栈，是用来管理执行上下文的。由于函数执行上下文是日常开发中的主要关注的执行上下文，可以认为调用栈是用来维护函数调用关系的。在开发中可以通过浏览器开发者工具的<code>Call Stack</code>面板进行查看，对于开发调试，源码学习理解有重要的作用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行上下文声明的所有标识符都维护在一个叫做 “变量对象” 的对象上。在加入<code>let</code>和<code>const</code>之后，通过引入 词法环境 和词法环境栈，实现了块级作用域。</p><p>在执行上下文中，对于 “保存定义的变量和函数的对象”，有四个名词：</p><table><thead><tr><th>名词</th><th>缩写</th><th>含义</th></tr></thead><tbody><tr><td>变量对象</td><td>VO</td><td>保存<strong>上下文</strong>中定义的<strong>所有标识符</strong>的对象</td></tr><tr><td>变量环境</td><td>VE</td><td>保存<strong>上下文</strong>中定义的<strong>所有 var 声明 变量和函数标识符</strong>的对象</td></tr><tr><td>词法环境</td><td>LE</td><td>保存<strong>作用域</strong>中定义的<strong>所有 let, const 声明 变量和函数标识符</strong>的对象</td></tr><tr><td>作用域环境</td><td>SE</td><td>保存最终归属于所在作用域的标识符的对象，对于函数作用域 SE == VO，对于块作用域 SE == LE</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wogit</title>
      <link href="/blog//2021/03/wogit.html"/>
      <url>/blog//2021/03/wogit.html</url>
      
        <content type="html"><![CDATA[<p><code>wogit</code> 是一个 git clone 加速命令行工具，使用加速镜像解决从 <code>github</code> 克隆速度慢的问题，在很多情况下能够显著提升 clone 速度。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i wogit -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>wogit</code> 的使用，除了支持几个指定特定源的选项之外，其他的与 <code>git</code> 一致，基本是把<code>git</code>替换成<code>wogit</code>即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># from</span><span class="token function">git</span> clone https://github.com/chalk/chalk.git<span class="token comment"># ti</span>wogit clone https://github.com/chalk/chalk.git<span class="token comment"># 其他参数不变，跟使用git一样，如</span>wogit clone https://github.com/chalk/chalk.git --depth<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="镜像切换"><a href="#镜像切换" class="headerlink" title="镜像切换"></a>镜像切换</h2><p><code>wogit</code> 默认使用 <code>cnpmjs</code> 镜像，使用 <code>wogit -h</code> 可以随时查看镜像切换的选项</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">➜ wogit -hUsage: wogit [options]Options:  -V, --version   output the version number  -cn --cnpm      cnpmjs镜像(默认)  -fa --fastgit   fastgit镜像  -ge --gitee     gitee镜像  -gc --gitclone  gitclone镜像  -gh --github    使用原始github镜像  -h, --help      display help for command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># fastgit镜像</span>wogit clone https://github.com/chalk/chalk.git -fawogit clone https://github.com/chalk/chalk.git --fastgit<span class="token comment"># gitee镜像</span>wogit clone https://github.com/chalk/chalk.git -gewogit clone https://github.com/chalk/chalk.git -gitee<span class="token comment"># 其他不一而足</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：并非所有的仓库都有加速，请根据提示，确认是否需要使用<code>-gh</code>强制直接使用 <code>github</code> 。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><code>wogit</code> 只会在 <strong>操作为clone且远程为github仓库</strong> 时才会使用加速的源，其他情况它是透传给<code>git</code>的，因此 clone 外的其他操作也是 OK 的。</p><p>可以是可以啦</p><p>但是</p><p>原汁原味的 <code>git</code> 它不香吗</p><p>只在 clone github 时用 wogit 就好啦</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>404</title>
      <link href="/blog/404/index.html"/>
      <url>/blog/404/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>contact</title>
      <link href="/blog/contact/index.html"/>
      <url>/blog/contact/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/blog/categories/index.html"/>
      <url>/blog/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/blog/about/index.html"/>
      <url>/blog/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>friends</title>
      <link href="/blog/friends/index.html"/>
      <url>/blog/friends/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/blog/tags/index.html"/>
      <url>/blog/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>blog</title>
      <link href="/blog/entry/index.html"/>
      <url>/blog/entry/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
